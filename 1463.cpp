#include <iostream>
#include <algorithm>
using namespace std;

int N;
int dp[1000001];

int main() {
    cin.sync_with_stdio(0);
    cin.tie(0);
    cin >> N;
    
    dp[1] = 0;
    for(int i=2;i<=N;i++) {
        dp[i] = dp[i-1] + 1;
        if(i%2==0) dp[i] = min(dp[i/2]+1, dp[i]);
        if(i%3==0) dp[i] = min(dp[i/3]+1, dp[i]);
    }
    cout << dp[N];
    return 0;
}
/*
3으로 나누어 떨어지면, 3으로 나눌 수 있다.
2로 나누어 떨어지면, 2로 나눌 수 있다.
1을 뺀다.

이 세가지 연산으로, 최소 연산으로 1을 만들어야 한다.
2로 나누는 것보다 3으로 나누는 것이 무조건 빠르게 수를 줄인다.
(4의 경우도, 4>2>1 <-> 4>3>1. 무조건 같거나 빠르다.)
따라서, 3의 배수가 될 때까지 -1을 해주고(그래봤자 최대 2번이다.) 3으로 나눈다.
3의 배수가 아니라면, 또 -1을 해주고 계속 3으로 나눈다.
만약 2나 3이 나온다면, cnt를 1 올려주고 끝낸다. -> 틀림

안된다. DP로 차근 차근 쌓아 나가 보자.
기본적으로 1을 빼는 연산이 있으니 dp[i] = dp[i-1] + 1이다.
2로 나누어질 때 dp[i] = dp[i/2] + 1
3으로 나누어질 때 dp[i] = dp[i/3] + 1이다.
세 연산 중 가장 작은 값을 넣어준다.

*/